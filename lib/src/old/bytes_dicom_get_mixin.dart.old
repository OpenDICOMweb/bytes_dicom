//  Copyright (c) 2016, 2017, 2018,
//  Poplar Hill Informatics and the American College of Radiology
//  All rights reserved.
//  Use of this source code is governed by the open source license
//  that can be found in the odw/LICENSE file.
//  Primary Author: Jim Philbin <jfphilbin@gmail.edu>
//  See the AUTHORS file for other contributors.
//
import 'dart:convert' as cvt;
import 'dart:typed_data';

import 'package:bytes/bytes.dart';
// import 'package:bytes_dicom/src/bytes/bytes_dicom_mixin.dart';
import 'package:bytes_dicom/src/dicom_constants.dart';
import 'package:bytes_dicom/src/vr/vr_base.dart';

/// The type of VR encoding.
enum VRType {
  /// Explicit VR Big Endian
  evrBE,

  /// Explicit VR Little Endian
  evrLE,

  /// Implicit VR
  ivr
}

const int _kNull = 0;
const int _kSpace = 0x20;

final _ascii = cvt.ascii.decode;
final _latin = cvt.latin1.decode;

String _utf8(List<int> list, {bool allowInvalid}) {
  final u8List = (list is Uint8List) ? list : Uint8List.fromList(list);
  return cvt.utf8.decode(u8List, allowMalformed: allowInvalid);
}

/// A class ensures that all [Bytes] are of an even length, by adding
/// a padding character, which defaults to ' ', if necessary.
mixin BytesDicomGetMixin {
 // @override
 // Endian get endian;

  Uint8List get buf;

  int get length;

  /// Returns _true_ if _this_ is Explicit VR.
  bool get isEvr;

  /// Returns the offset to the Value Field Length field.
  int get vfLengthOffset;

  /// The value of the Value Field length field.
  int get vfLengthField;

  /// The offset in _this_ to the Value Field.
  int get vfOffset;

  int getUint8(int offset);
  int getUint16(int offset);
  int getUint32(int offset);


  // **** End of interface

  /// The DICOM Tag Code of _this_.
  int get code => getCode(0);

  /// The Element Group Field
  int get group => getUint16(0);

  /// The Element _element_ Field.
  int get elt => getUint16(2);

  /// Returns the offset in _this_ to VR field.
  int get vrOffset => 4;

  /// The VR code of _this_.
  int get vrCode => throw UnsupportedError('Unsupported');

  /// Returns the internal VR index of _this_.
  int get vrIndex => vrIndexFromCode(vrCode);

  ///  Returns the identifier of the VR of _this_.
  String get vrId => vrIdFromIndex(vrIndex);

//  Tag get tag => Tag.lookup(code);

  /// Returns _true_ if [vfLengthField] equals [kUndefinedLength].
  bool get hasUndefinedLength => vfLengthField == kUndefinedLength;

  /// Returns the actual length of the Value Field.
  int get vfLength => buf.length - vfOffset;

  /// Returns the Value Field bytes.
  Bytes get vfBytes => asBytes(vfOffset, vfLength);

  /// Returns the last Uint8 element in [vfBytes], if [vfBytes]
  /// is not empty; otherwise, returns _null_.
  int get vfBytesLast {
    final len = length;
    return (len == 0) ? null : getUint8(len - 1);
  }

  /// Returns the Value Field as a Uint8List.
  Uint8List get vfUint8List =>
      buf.buffer.asUint8List(buf.offsetInBytes + vfOffset, vfLength);

  /// If _true_ padding at the end of Value Fields will be ignored.
  ///
  /// _Note_: Only used by == operator.
  bool noPadding = true;

  /// Gets the DICOM Tag Code at [offset].
  int getCode(int offset) {
    final group = getUint16(offset);
    final elt = getUint16(offset + 2);
    return (group << 16) + elt;
  }

  /// Sets the _code_ of _this_ to [code].
  void setCode(int code) {
    setUint16(0, code >> 16);
    setUint16(2, code & 0xFFFF);
  }

  void setVRCode(int vrCode) {
    setUint8(4, vrCode >> 8);
    setUint8(5, vrCode & 0xFF);
  }

  int getShortVLF(int offset) => getUint16(offset);
  void setShortVLF(int vlf) => setUint16(6, vlf);

  int getLongVLF(int offset) => getUint32(offset);
  void setLongVLF(int vlf) => setUint32(8, vlf);

  /// Returns a [String] containing a _ASCII_ decoding of the specified region.
  /// Also, allows the removal of padding characters.
  @override
  String getAscii([int offset = 0, int length]) =>
      _getString(offset, length, _ascii);

  /// Returns a [List<String>]. This is done by first decoding
  /// the specified region as _ASCII_, and then _split_ing the
  /// resulting [String] using the _backslash_ character. Also allows the
  /// removal of a padding character.
  @override
  List<String> getAsciiList([int offset = 0, int length]) =>
      _split(_getString(offset, length, _ascii));

  /// Returns a [String] containing a _Latin_ decoding of the specified region.
  /// Also, allows the removal of padding characters.
  @override
  String getLatin([int offset = 0, int length]) =>
      _getString(offset, length, _latin);

  /// Returns a [List<String>]. This is done by first decoding
  /// the specified region as _Latin_, and then _split_ing the
  /// resulting [String] using the _backslash_ character.
  @override
  List<String> getLatinList([int offset = 0, int length]) =>
      _split(_getString(offset, length, _latin));

  /// Returns a [String] containing a _UTF-8_ decoding of the specified region.
  /// Also, allows the removal of padding characters.
  @override
  String getUtf8([int offset = 0, int length]) =>
      _getString(offset, length, _utf8);

  /// Returns a [List<String>]. This is done by first decoding
  /// the specified region as _UTF-8_, and then _split_ing the
  /// resulting [String] using the _backslash_ character.
  @override
  List<String> getUtf8List([int offset = 0, int length]) =>
      _split(_getString(offset, length, _utf8));

  /// Returns a [String] containing a decoding of the specified region.
  /// If [decoder] is not specified, it defaults to _UTF-8_.
  @override
  String getString([int offset = 0, int length, Decoder decoder]) =>
      _getString(offset, length, decoder);

  /// Returns a [List<String>]. This is done by first decoding
  /// the specified region as _UTF-8_, and then _split_ing the
  /// resulting [String] using the _backslash_ character.
  @override
  List<String> getStringList([int offset = 0, int length, Decoder decoder]) =>
      _split(_getString(offset, length, decoder ?? _utf8));

  String _getString(int offset, int length, Decoder decoder) {
    var list = asUint8List(offset, length);
    list = noPadding ? _removePadding(list) : list;
    return list.isEmpty ? '' : decoder(list, allowInvalid: allowInvalid);
  }

  Uint8List _removePadding(Uint8List list) {
    if (list.isEmpty) return list;
    final lastIndex = list.length - 1;
    final c = list[lastIndex];
    return (c == _kSpace || c == _kNull)
        ? list.buffer.asUint8List(list.offsetInBytes, lastIndex)
        : list;
  }

  List<String> _split(String s) {
    final x = s.trimLeft();
    return (x.isEmpty) ? <String>[] : s.split(stringSeparator);
  }

  @override
  String toString() => '$runtimeType: offset: $offset length: $length';

  /// A DicomBytes with length 0.
  static BytesDicom kEmpty = Bytes.kEmptyBytes;

  // Urgent: unit test
  /// Returns a [Bytes] containing the Utf8 decoding of [s].
  static BytesDicom fromAscii(String s,
          [int maxLength, String padChar = ' ']) =>
      _stringToBytes(s, maxLength ?? s.length, padChar, cvt.ascii.encode);

  /// Returns a [Bytes] containing the ASCII encoding of [list].
  static BytesDicom fromAsciiList(List<String> list,
          [int maxLength, String padChar = ' ']) =>
      _listToBytes(list, maxLength, padChar, cvt.ascii.encode);

  // Urgent: unit test
  /// Returns a [Bytes] containing the Utf8 decoding of [s].
  static BytesDicom fromLatin(String s,
          [int maxLength, String padChar = ' ']) =>
      _stringToBytes(s, maxLength ?? s.length, padChar, cvt.ascii.encode);

  /// Returns a [Bytes] containing the Latin encoding of [list].
  static BytesDicom fromLatinList(List<String> list,
          [int maxLength, String padChar = ' ']) =>
      _listToBytes(list, maxLength, padChar, cvt.ascii.encode);

  // Urgent: unit test
  /// Returns a [Bytes] containing the Utf8 decoding of [s].
  static BytesDicom fromUtf8(String s,
          [int maxLength, String padChar = ' ']) =>
      _stringToBytes(s, maxLength ?? s.length, padChar, cvt.utf8.encode);

  /// Returns a [Bytes] containing the ASCII encoding of [list].
  static BytesDicom fromUtf8List(List<String> list,
          [int maxLength, String padChar = ' ']) =>
      _listToBytes(list, maxLength, padChar, cvt.ascii.encode);

  /// Returns a [Uint8List] corresponding to a binary Value Field.
  static Bytes fromTextList(Iterable<String> list) {
    if (list.isEmpty) return BytesDicom.kEmpty;
    if (list.length != 1) throw ArgumentError('Text has only one value:$list');
    return fromUtf8List(list);
  }

  // Urgent: unit test
  /// Returns a [Bytes] containing the Utf8 decoding of [s].
  static BytesDicom fromString(String s,
          [int maxLength, String padChar = ' ', Uint8List decoder(String s)]) =>
      fromString(s, maxLength ?? s.length, padChar, decoder);

  /// Returns a [Bytes] containing the ASCII encoding of [list].
  static BytesDicom fromStringList(List<String> list,
          [int maxLength, String padChar = ' ', Uint8List decoder(String s)]) =>
      _listToBytes(list, maxLength, padChar, decoder);

  // Urgent: unit test
  /// Returns a [Bytes] containing the Base64 decoding of [s].
  static BytesDicom fromBase64(String s,
          [int maxLength, String padChar = ' ']) =>
      _stringToBytes(s, maxLength ?? s.length, padChar, cvt.ascii.encode);
}

/*
/// A class ensures that all [Bytes] are of an even length, by adding
/// a padding character, which defaults to ' ', if necessary.
class BytesDicomLE extends BytesDicom
    with LittleEndianGetMixin, LittleEndianSetMixin, DicomBytesPrimitives {
  /// Creates a new [BytesDicomLE] from [buf].
  BytesDicomLE(Uint8List buf) : super(buf);

  /// Creates an empty [BytesDicomLE] of [length] and [endian].
  BytesDicomLE.empty([int length = 4096]) : super.empty(length);

  /// Creates a [BytesDicomLE] from a copy of [bytes].
  BytesDicomLE.from(Bytes bytes, [int offset = 0, int length])
      : super.from(bytes, offset, length);

  /// Creates a new [Bytes] from a [TypedData] containing the specified
  /// region and [endian]ness.  [endian] defaults to [Endian.little].
  BytesDicomLE.typedDataView(TypedData td, [int offset = 0, int length])
      : super.typedDataView(td, offset, length ?? td.lengthInBytes);
}

/// A class ensures that all [Bytes] are of an even length, by adding
/// a padding character, which defaults to ' ', if necessary.
class BytesDicomBE extends BytesBigEndian
    with DicomBytesPrimitives, BytesDicomMixin {
  /// Creates a new [BytesDicomBE] from [buf].
  BytesDicomBE(Uint8List buf) : super(buf);

  /// Creates an empty [BytesDicomBE] of [length] and [endian].
  BytesDicomBE.empty([int length = 4096]) : super.empty(length);

  /// Creates a [BytesDicomBE] from a copy of [bytes].
  BytesDicomBE.from(Bytes bytes, [int offset = 0, int length])
      : super.from(bytes, offset, length);

  /// Creates a new [Bytes] from a [TypedData] containing the specified
  /// region and [endian]ness.  [endian] defaults to [Endian.little].
  BytesDicomBE.typedDataView(TypedData td, [int offset = 0, int length])
      : super.typedDataView(td, offset, length ?? td.lengthInBytes);
}

mixin DicomBytesPrimitives {
  int get vfOffset => throw UnsupportedError('Not supported.');

  int get vfLengthField => throw UnsupportedError('Not supported.');
}
*/

// Urgent: unit test
/// Returns a [Bytes] containing the Base64 decoding of [s].
BytesDicom _stringToBytes(
    String s, int maxLength, String padChar, Uint8List decoder(String s)) {
  if (s.isEmpty) return Bytes.kEmptyBytes;
  var bList = decoder(s);
  if (padChar != null) {
    final bLength = bList.length;
    if (bLength.isOdd && padChar != null) {
      // Performance: It would be good to eliminate this copy
      final nList = Uint8List(bLength + 1);
      for (var i = 0; i < bLength - 1; i++) nList[i] = bList[i];
      nList[bLength] = padChar.codeUnitAt(0);
      bList = nList;
    }
  }
  return Bytes.typedDataView(bList);
}

/// Returns a [Bytes] containing a decoding of [list].
Bytes _listToBytes(List<String> list, int maxLength, String padChar,
    Uint8List decoder(String s)) {
  final s = list.join('\\').trimLeft();
  return _stringToBytes(s, maxLength, padChar, decoder);
}

bool _bytesEqual(Bytes a, Bytes b) {
  final aLen = a.length;
  if (aLen != b.length) return false;
  for (var i = 0; i < aLen; i++) if (a[i] != b[i]) return false;
  return true;
}

// TODO: test performance of _uint16Equal and _uint32Equal
bool __bytesEqual(Bytes a, Bytes b, bool ignorePadding) {
  final len0 = a.length;
  final len1 = b.length;
  if (len0 != len1) return false;
  if ((len0 % 4) == 0) {
    return _uint32Equal(a, b, ignorePadding);
  } else if ((len0 % 2) == 0) {
    return _uint16Equal(a, b, ignorePadding);
  } else {
    return _uint8Equal(a, b, ignorePadding);
  }
}

// Note: optimized to use 4 byte boundary
bool _uint8Equal(Bytes a, Bytes b, bool ignorePadding) {
  for (var i = 0; i < a.length; i += 1) {
    final x = a.buf[i];
    final y = b.buf[i];
    if (x != y) return _bytesMaybeNotEqual(i, a, b, ignorePadding);
  }
  return true;
}

// Note: optimized to use 2 byte boundary
bool _uint16Equal(Bytes a, Bytes b, bool ignorePadding) {
  for (var i = 0; i < a.length; i += 2) {
    final x = a.getUint16(i);
    final y = b.getUint16(i);
    if (x != y) return _bytesMaybeNotEqual(i, a, b, ignorePadding);
  }
  return true;
}

// Note: optimized to use 4 byte boundary
bool _uint32Equal(Bytes a, Bytes b, bool ignorePadding) {
  for (var i = 0; i < a.length; i += 4) {
    final x = a.getUint32(i);
    final y = b.getUint32(i);
    if (x != y) return _bytesMaybeNotEqual(i, a, b, ignorePadding);
  }
  return true;
}

bool _bytesMaybeNotEqual(int i, Bytes a, Bytes b, bool ignorePadding) {
  var errorCount = 0;
  final ok = __bytesMaybeNotEqual(i, a, b, ignorePadding);
  if (!ok) {
    errorCount++;
    if (errorCount > 3) throw ArgumentError('Unequal');
    return false;
  }
  return true;
}

bool __bytesMaybeNotEqual(int i, Bytes a, Bytes b, bool ignorePadding) {
  if ((a[i] == 0 && b[i] == 32) || (a[i] == 32 && b[i] == 0)) {
    //  log.warn('$i ${a[i]} | ${b[i]} Padding char difference');
    return ignorePadding;
  } else {
    _warnBytes(i, a, b);
    return false;
  }
}

void _warnBytes(int i, Bytes a, Bytes b) {
  final x = a[i];
  final y = b[i];
  print('''
$i: $x | $y')
	  "${String.fromCharCode(x)}" | "${String.fromCharCode(y)}"
	    '    $a')
      '    $b')
      '    ${a.getAscii()}')
      '    ${b.getAscii()}');
''');
}
