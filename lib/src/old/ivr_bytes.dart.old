//  Copyright (c) 2016, 2017, 2018,
//  Poplar Hill Informatics and the American College of Radiology
//  All rights reserved.
//  Use of this source code is governed by the open source license
//  that can be found in the odw/LICENSE file.
//  Primary Author: Jim Philbin <jfphilbin@gmail.edu>
//  See the AUTHORS file for other contributors.
//
import 'dart:typed_data';

import 'package:bytes/bytes.dart';
import 'package:bytes_dicom/src/bytes/element_interface.dart';
import 'package:bytes_dicom/src/bytes/bytes_dicom.dart';
import 'package:bytes_dicom/src/bytes/evr_bytes_mixin.dart';
import 'package:bytes_dicom/src/bytes/to_string_mixin.dart';
import 'package:bytes_dicom/src/vr/vr_base.dart';

/// Implicit Little Endian [Bytes] with short (16-bit) Value Field Length.
class BytesIvr extends BytesDicom
    with
        LittleEndianGetMixin,
        LittleEndianSetMixin,
        BytesDicomMixin,
        ToStringMixin
    implements ElementInterface {

  /// Returns an [BytesIvr] containing [buf].
  BytesIvr(Uint8List buf) : super._(buf);

  /// Creates an empty [BytesIvr] of [length].
  BytesIvr.empty(int length)
      : super._empty(length);

  /// Create an [BytesIvr] Element from [Bytes].
  BytesIvr.from(Bytes bytes, int start, int length)
      : super._from(bytes, start, length);

  /// Create an [BytesIvr] Element from a view of [Bytes].
  BytesIvr._typedDataView(Bytes bytes, [int start = 0, int length])
      : super._typedDataView(bytes, start, length);

  /// Returns an [BytesIvr] with an empty Value Field.
  factory BytesIvr.element(int code, int vrCode, int vfLength) {
    assert(vfLength.isEven);
    return BytesIvr.empty(kVFOffset + vfLength)
      ..setHeader(code, vfLength, vrCode);
  }

  /// Creates an [BytesIvr].
  factory BytesIvr.makeFromBytes(int code, int vrCode, Bytes vfBytes) {
    final vfLength = vfBytes.length;
    assert(vfLength.isEven);
    return BytesIvr.empty(kVFOffset + vfLength)
      ..setHeader(code, vfLength, vrCode)
      ..setUint8List(kVFOffset, vfBytes.buf);
  }

  /// Returns _false_.
  @override
  bool get isEvr => false;
  @override
  int get vrOffset => throw UnsupportedError('VR not supported');
  @override
  int get vrCode => kUNCode;
  @override
  int get vrIndex => kUNIndex;
  @override
  String get vrId => 'UN';
  @override
  int get vfOffset => kVFOffset;

  /// The byte offset from the beginning of the Element
  /// to the Value Length Field.
  @override
  int get vfLengthOffset => 4;

  @override
  int get vfLengthField {
    final vlf = getUint32(vfLengthOffset);
    assert(checkVFLengthField(vlf, vfLength));
    return vlf;
  }

  @override
  int get vfLength => buf.length - 8;

  /// Returns the Value Field bytes.
  @override
  Bytes get vfBytes => asBytes(vfOffset, vfLength);

  // TODO: make private?
  /// Write a short EVR header.
  void setHeader(int offset, int code, int vlf) {
    setUint16(offset, code >> 16);
    setUint16(2, code & 0xFFFF);
    setUint32(4, vlf);
  }

  /// Returns a copy of _this_ containing the bytes from [start] inclusive
  /// to [end] exclusive. If [end] is omitted, the [length] of _this_ is used.
  /// An error occurs if [start] is outside the range 0 .. [length],
  /// or if [end] is outside the range [start] .. [length].
  @override
  BytesIvr sublist([int start = 0, int end]) =>
      BytesIvr.from(this, start, (end ?? length) - start);

  /// The offset of the Value Field in an IVR Element
  static const int kVFOffset = 8;
}
